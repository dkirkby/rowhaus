#!/usr/bin/python3

import time
import multiprocessing

import flask


class Simulator(multiprocessing.Process):

    def __init__(self, queue):
        multiprocessing.Process.__init__(self)
        self.exit = multiprocessing.Event()
        self.queue = queue
        self.count = 0

    def run(self):
        while not self.exit.is_set():
            now = time.time()
            delay = 1.
            time.sleep(delay)
            payload = (self.count, now, delay, 0.05 * delay)
            if self.queue.full():
                self.queue.get()
            self.queue.put(payload)
            print(payload)
            self.count += 1
        self.queue.close()
        print('closed')

    def shutdown(self):
        self.exit.set()
        

class SwitchMonitor(multiprocessing.Process):

    def __init__(self, queue):
        multiprocessing.Process.__init__(self)
        self.exit = multiprocessing.Event()
        self.queue = queue
        self.SWITCH = 5
        GPIO.setmode(GPIO.BOARD)
        # Channel has a hardware pullup.
        GPIO.setup(self.SWITCH, GPIO.IN)

        self.count = 0
        self.last_time = [0, time.time()]
        self.last_state = -1

    def edge(self, pin):
        if pin != self.SWITCH:
            return
        new_state = GPIO.input(self.SWITCH)
        new_time = time.time()
        if new_state == 1 and self.last_state == 0:
            # Calculate elapsed times.
            payload = self.count, new_time, new_time - self.last_time[1], new_time - self.last_time[0]
            if self.queue.full():
                self.queue.get()
            self.queue.put(payload)
            self.count += 1
        self.last_time[new_state] = new_time
        self.last_state = new_state

    def run(self):
        GPIO.add_event_detect(self.SWITCH, GPIO.BOTH, callback=self.edge, bouncetime=1)
        while not self.exit.is_set():
            time.sleep(10)
        self.queue.close()
        print('closed')

    def shutdown(self):
        self.exit.set()


app = flask.Flask(__name__, static_url_path='')

@app.route('/')
def root():
    return app.send_static_file('index.html')

q = multiprocessing.Queue(maxsize=16)

@app.route('/monitor')
def monitor():
    # Wait for the next queue entry if necessary
    count, t, dt1, dt2 = q.get()
    return flask.jsonify(count=count, t=t, dt1=dt1, dt2=dt2)


if __name__ == '__main__':

    # Start the background process that monitors the rowing machine.    
    try:
        # Use GPIO to monitor the rowing machine.
        import RPi.GPIO as GPIO
        p = SwitchMonitor(q)
    except ImportError:
        # Start a background process that simulates the rowing machine.
        p = Simulator(q)

    p.start()
        
    # Start the web server.
    app.run(host='0.0.0.0', port=80)
